#!/usr/bin/perl
#-----------------------------------------------------------------------------
#
#  The Flinch link checker
#
#  https://github.com/joto/flinch
#  https://www.jochentopf.com/software/flinch/index.html
#
#-----------------------------------------------------------------------------
#
#  Copyright (C) 2001-2020  Jochen Topf <jochen@remote.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
#
#-----------------------------------------------------------------------------

use XML::Generator;
use XML::Parser::PerlSAX;
use HTML::LinkExtor;
use HTML::HeadParser;
use LWP::UserAgent;
use URI;
use HTTP::Status;
use Time::HiRes qw(gettimeofday tv_interval);
use Getopt::Long;
use Carp;

use strict;


my $CFGDIR  = "$ENV{'HOME'}/.flinch";

my $VERSION = "1.1.0";
my $PROGRAM = "Flinch";

my $AD_TEXT = "generated by Flinch $VERSION";
my $AD_URL  = "https://github.com/joto/flinch";


#-----------------------------------------------------------------------------
#              NO USER SERVICABLE PARTS BEYOND THIS POINT
#-----------------------------------------------------------------------------

my $HOSTNAME = `hostname`;
chomp $HOSTNAME;


#-----------------------------------------------------------------------------
# This is the default configuration. It can be overwritten in the config.xml
# file.
#-----------------------------------------------------------------------------
my $cfg = Flinch::Config->new(
    'stylesheet'   => 'flinch-style.css',
    'timeout'      => 60,
    'sleep'        => 0.1,
    'schemes'      => 'http https',
    'useragent'    => "$PROGRAM/$VERSION",
    'warn'         => '3d',
    'emailfrom'    => 'flinch@' . $HOSTNAME,
    'reportprefix' => '',
);


#-----------------------------------------------------------------------------
#
#  global variables
#
#-----------------------------------------------------------------------------
my $intern; # internal URLs

my %opts = ('verbose' => 0, 'configdir' => $CFGDIR);

my @standardoptions = ('verbose+', 'configdir=s', 'time=i');

my $got_signal_int = 0;
my $got_signal_hup = 0;

my %last = ('walk' => 0, 'check' => 0, 'report' => 0, 'mail' => 0);

my %failed = ();

#-----------------------------------------------------------------------------
#
#  main program
#
#-----------------------------------------------------------------------------
{
    my %subcommands = map { $_ => 1 }
        qw(check clean edit help info init mail recycle report walk version);

    my $sc = shift;

    if ($subcommands{$sc}) {
        $sc = "do_$sc";
        no strict 'refs';
        &$sc(@ARGV);
    } else {
        print STDERR "$0: unknown subcommand '$sc'. Try '$0 help'\n";
        exit(1);
    }
}

exit(0);


#-----------------------------------------------------------------------------
#
#  get_project()
#
#-----------------------------------------------------------------------------
sub get_project {
    my ($check_empty) = @_;
    die("$0: missing PROJECT argument\n") if ($#ARGV == -1 && $check_empty);
    die("$0: too many arguments\n") if ($#ARGV > 0);
    return $ARGV[0];
}


#-----------------------------------------------------------------------------
#
#  set_signals()
#
#-----------------------------------------------------------------------------
sub set_signals {
    $SIG{'TERM'} = sub { $got_signal_int = 1; };
    $SIG{'INT'}  = sub { $got_signal_int = 1; };
    $SIG{'HUP'}  = sub { $got_signal_hup = 1; };
}


#-----------------------------------------------------------------------------
#
#  standard_init()
#
#-----------------------------------------------------------------------------
sub standard_init {
    my $todo = shift;
    GetOptions(\%opts, @standardoptions, @_);
    read_config_xml();
    read_project_xml(get_project(1));

    set_signals();

    $cfg->dump() if ($opts{'verbose'});

    $cfg->check_complete();

    if ($todo) {
        if (time() - $last{$todo} < $opts{'time'} * 60 * 60) {
            print STDERR "$0: last run was less then $opts{'time'} hours ago\n";
            exit(0);
        }
        $last{$todo} = time();
    }
}


#-----------------------------------------------------------------------------
#
#  do_version()
#
#  Print program version.
#
#-----------------------------------------------------------------------------
sub do_version {
    print "$0 $VERSION\n";
}


#-----------------------------------------------------------------------------
#
#  do_help()
#
#  Print usage information.
#
#-----------------------------------------------------------------------------
sub do_help {
    print <<"EOF";
Usage: $0 SUBCOMMAND [OPTIONS] ... PROJECT
A web link checker

Subcommands are:
  init     initialize project
  walk     walk the site to find all internal pages and all external links
  check    check external links
  mail     send mail with warnings
  report   output a HTML report
  edit     edit XML config file
  clean    clean project file history
  help     print this help text
  version  print version

General options:
  -v, --verbose        be verbose
  -v -v                be very verbose
  -c, --configdir=DIR  config directory (default: ~/.flinch)

Options for check:
  -r, --restrict=LIST  restrict check to some states. LIST is a comma
                       separated list of states (ok, warn, error, unchecked)

EOF
}


#-----------------------------------------------------------------------------
#
#  do_info()
#
#  This function reads the XML file and parses it. With -v it can be used
#  to show the current configuration.
#
#-----------------------------------------------------------------------------
sub do_info {
    standard_init();
}


#-----------------------------------------------------------------------------
#
#  do_recycle()
#
#  This function reads the XML file, parses it and writes it back. It is
#  mainly used for testing.
#
#-----------------------------------------------------------------------------
sub do_recycle {
    standard_init();
    write_project_xml();
}


#-----------------------------------------------------------------------------
#
#  do_clean()
#
#  This function reads the XML file, parses it and writes it back. It is
#  mainly used for testing.
#
#-----------------------------------------------------------------------------
sub do_clean {
    standard_init();

    print "Cleaning history...\n" if ($opts{'verbose'});
    foreach my $link (Flinch::ExternLink->get_list()) {
        $link->get_history()->clean();
    }

    write_project_xml();
}


#-----------------------------------------------------------------------------
#
#  do_edit()
#
#  Call editor with XML config file.
#
#-----------------------------------------------------------------------------
sub do_edit {
    GetOptions(\%opts, @standardoptions);
    read_config_xml();
    my $project = get_project(1);

    my $file = "$opts{'configdir'}/$project.xml";
    my $editor = $ENV{'XMLEDITOR'} || $ENV{'EDITOR'} || 'vi';
    system("cp $file $file.$$") and die("Copying config file failed\n");
    system("$editor $file.$$");
    rename("$file.$$", $file) or die("Can't rename temp file '$file.$$' to config file '$file': $!\n");
}


#-----------------------------------------------------------------------------
#
#  do_init()
#
#  Create initial project XML file after asking the user for some config vars.
#
#-----------------------------------------------------------------------------
sub do_init {
    GetOptions(\%opts, @standardoptions);

    if (! -d $opts{'configdir'}) {
        print STDERR "Directory $opts{'configdir'} not found. Do you want to\n";
        print STDERR "create it and write the main configuration file (config.xml)\n";
        print STDERR "into it? (Flinch won't work without it) [y/n]\n";
        my $line = <STDIN>;
        if ($line =~ /^y$/i) {
            mkdir($opts{'configdir'}, 0755) or die("Can't create $opts{'configdir'}: $!\n");
            write_config_xml();
        } else {
            print STDERR "I can't go on without the config.xml file...\n";
            exit(1);
        }
    }

    if (! -f "$opts{'configdir'}/config.xml") {
        print STDERR "Main config file $opts{'configdir'}/config.xml not found.\n";
        print STDERR "Do you want to create it? (Flinch won't work without it) [y/n]\n";
        my $line = <STDIN>;
        if ($line =~ /^y$/i) {
            write_config_xml();
        } else {
            print STDERR "I can't go on without the config.xml file...\n";
            exit(1);
        }
    }

    read_config_xml();
    my $project = get_project(0);

    $cfg->set_project(ask_for("Enter project name:", $project, qr/^[a-zA-Z0-9_-]+$/ )); #/

    if (-f "$opts{'configdir'}/" . $cfg->get_project() . '.xml') {
        die('Project ' . $cfg->get_project() . ' already exists\n');
    }

    $cfg->set_prefix(ask_for("Enter URL prefix for all pages of this project", ""));
    $cfg->set_startpath(ask_for("Enter start URL (relative to the prefix)", "/index.html"));

    my $dir = $cfg->get_reportdir();
    $dir =~ s/%p/$cfg->get_project()/e;
    $cfg->set_reportdir(ask_for("Enter directory for HTML report", $dir));

    my $url = $cfg->get_reporturl();
    $url =~ s/%p/$cfg->get_project()/e;
    $cfg->set_reporturl(ask_for("Enter URL for HTML report", $url));

    $cfg->set_email(ask_for("Enter email address where reports should be sent", $cfg->get_email()));

    print <<"EOF";
If you haven't done so yet, you should now create the report directory and
copy the 'flinch-style.css' CSS style sheet into it.
EOF

    set_signals();
    write_project_xml();
}


sub ask_for {
    my ($desc, $default, $re) = @_;

    $| = 1;
    my $in;
    do {
        print "$desc [$default]:\n> ";
        $in = <STDIN>;
        chomp $in;

        $in = $default if ($in eq "");
        return $in if (defined $re && $in =~ $re);
    } while (defined $re);

    print "\n";
    return $in;
}


#-----------------------------------------------------------------------------
#
#  do_walk()
#
#  Starting at the configured start page, this function will walk your web
#  site to find all internal pages and all external links.
#
#-----------------------------------------------------------------------------
sub do_walk {
    standard_init('walk');

    $_->flush_ref() foreach (Flinch::ExternLink->get_list());

    my $ua = init_user_agent();

    $intern = Flinch::URLList->new();
    $intern->push($cfg->get_prefix() . $cfg->get_startpath());

    print "Walking the web site\n" if ($opts{'verbose'});
    my $url;
    while ($url = $intern->pop()) {
        get_page($ua, $url);
        if ($got_signal_int) {
            print STDERR "Interrupted by a signal. XML file will not be written.\n";
            exit(2);
        }
    }

    # print failed URLs
    foreach my $link (sort(keys(%failed))) {
        print "Failed to get $link\n";
    }

    # go through the list of all external links and check whether they are
    # still needed
    print "Removing orphaned external links\n" if ($opts{'verbose'});
    foreach my $link (Flinch::ExternLink->get_list()) {
        if (! $link->is_referenced()) {
            print "  ", $link->get_url(), "\n" if ($opts{'verbose'});
            $link->remove();
        }
    }

    write_project_xml();
}


sub do_request {
    my ($agent, $method, $url) = @_;

    my $request = HTTP::Request->new($method, $url);
    return $agent->simple_request($request);
}


sub get_page {
    my ($ua, $url) = @_;

    # first get header only to check type of document
    my $response = eval { do_request($ua, 'HEAD', $url); };
#  my $request = eval { HTTP::Request->new('HEAD', $url); };
#  my $response = $ua->simple_request($request);

    if ($@ || $response->is_error()) {

        Flinch::URLList->bad_refs($url);

        print "  FAILED $url\n" if ($opts{'verbose'});
        $failed{$url} = 1;
        return;
    }

    # if it is not a text/html document, there is nothing to be done
    if ($response->content_type() ne "text/html") {
        print "  NOHTML $url\n" if ($opts{'verbose'});
        return;
    }

    foreach my $skip (Flinch::Skip->list_nofollow()) {
        if ($skip->match($url)) {
            print "  SKIP   $url\n" if ($opts{'verbose'});
            return;
        }
    }

    print "  HTML   $url\n" if ($opts{'verbose'});

    # now get content of document
#  $request = HTTP::Request->new('GET', $url);
#  $response = $ua->simple_request($request);
    $response = eval { do_request($ua, 'GET', $url); };

    if ($@ || $response->is_error()) {

        Flinch::URLList->bad_refs($url);

        print "  FAILED $url\n" if ($opts{'verbose'});
        $failed{$url} = 1;
        return;
    }

    # get <base href>
    my $hp = HTML::HeadParser->new;
    $hp->parse($response->content());
    my $base = $hp->header('Content-Base');
    $base =~ s@[^/]+$@@;

    if ($base) {
        $url = URI->new($base)->abs($url);
    }

    # parse document and get out all links to other documents
    my $p = HTML::LinkExtor->new(undef, $url);
    $p->parse($response->content());

    foreach my $element ($p->links()) {
        if ($element->[0] ne 'base') {
            shift @$element;
            my %hash = @$element;
            foreach my $link (values(%hash)) {
                handle_link($link, $url);
            }
        }
    }
}


sub handle_link {
    my ($link, $url) = @_;

    my $l = $link->as_string();

    print "    LINK $l\n" if ($opts{'verbose'} > 1);

    foreach my $skip (Flinch::Skip->list_ignore()) {
        if ($skip->match($l)) {
            print "  IGNORE $l\n" if ($opts{'verbose'});
            return;
        }
    }

    my $pre = $cfg->get_prefix();
    if ($l =~ /^$pre/o) {
        $l =~ s/\#.*$//;    # remove fragment identifier
        $intern->push($l, $url);
    } elsif ($cfg->scheme_ok($link->scheme())) {
        Flinch::ExternLink->new($l, $url);
    }
}


sub init_user_agent {
    my $ua = new LWP::UserAgent;
    $ua->agent($cfg->get_useragent());
    $ua->env_proxy();
    $ua->use_eval(0);
    $ua->timeout($cfg->get_timeout());
    return $ua;
}


#-----------------------------------------------------------------------------
#
#  do_check()
#
#  This function checks all external links. After each link the current state
#  is written to the XML file, so that the state is not lost, if the process
#  is terminated while checking a lengthy list of URLs.
#
#-----------------------------------------------------------------------------
sub do_check {
    standard_init('check', 'level=s@', 'state=s@', 'url=s', 'head');

    my %r_level = map { lc($_) => 1 } split(/,/, join(',', @{$opts{'level'}} )) if (exists $opts{'level'});
    my %r_state = map { lc($_) => 1 } split(/,/, join(',', @{$opts{'state'}} )) if (exists $opts{'state'});
    my %r_url   = map { $_ => 1 } $opts{'url'} if (exists $opts{'url'});

    my $ua = init_user_agent();

    foreach my $link (Flinch::ExternLink->get_list()) {
        if (( %r_level && ! $r_level{$link->get_history()->get_level()} ) ||
            ( %r_state && ! $r_state{$link->get_history()->get_state()} ) ||
            ( %r_url   && ! $r_url{$link->get_url()->as_string()} )) {
            print "Skipping ", $link->get_url(), "\n" if ($opts{'verbose'});
            next;
        }

        print "Checking ", $link->get_url(), "\n" if ($opts{'verbose'});
        my $headers = HTTP::Headers->new('Host' => $link->get_url()->host());

        my $result;
        if (! $opts{'head'} && $link->get_method() eq "GET") {
            $result = http_check($ua, 'GET', $link, $headers);
        } else {
            $result = http_check($ua, 'HEAD', $link, $headers);
            if ($result->get_code() != 200) {
                $link->set_method('GET');
                $result = http_check($ua, 'GET', $link, $headers);
            }
        }

        if ($result->get_state() eq 'ok' && $link->get_url()->as_string() =~ /^http:/) {
            my $https_link = $link->get_url()->as_string();
            $https_link =~ s/^http:/https:/;
            print "Link was okay, checking HTTPS version ", $https_link, "\n" if ($opts{'verbose'});
            my $response = http_request($ua, 'HEAD', $https_link, $headers);
            if ($response && ($response->code() == 200 || code_is_redirect($response->code()))) {
                print "Response was ", $response->code(), ", setting state to 'http'\n" if ($opts{'verbose'});
                $result->set_state('http');
                $result->set_location($https_link);
            }
        }

        $link->get_history()->add($result);

        if ($got_signal_int) {
            print STDERR "Interrupted by a signal. Check is not complete!\n";
            write_project_xml();
            exit(2);
        }
        if ($got_signal_hup) {
            print STDERR "Got SIGHUP. Writing current state to XML file...\n";
            write_project_xml();
            $got_signal_hup = 0;
        }

        if ($cfg->get_sleep() != 0) {
            print "Sleeping ", $cfg->get_sleep(), " seconds\n" if ($opts{'verbose'});
            Time::HiRes::sleep($cfg->get_sleep()); # Sleep to not overload server
        }
    }

    write_project_xml();
}


sub http_request {
    my ($ua, $type, $url, $headers) = @_;

    my $request = eval { HTTP::Request->new($type, $url, $headers); };

    my $response;
    if (! $@) {
        $response = eval { $ua->simple_request($request); };
    }

    return $response;
}

sub code_is_redirect {
    my ($code) = @_;

    return (($code >= 301) && ($code <= 303)) || ($code == 308);
}

sub http_check {
    my ($ua, $type, $link, $headers) = @_;

    my $t0 = [gettimeofday()];
    my $response = http_request($ua, $type, $link->get_url(), $headers);
    my $duration = tv_interval($t0, [gettimeofday()]);
    $duration = int($duration*100)/100;

    if ($@) {
        $@ =~ s/\s+/ /g;
        $@ =~ s/^ //g;
        $@ =~ s/ $//g;

        my $state;
        if    ($@ =~ /timeout/i)      { $state = "timeout"; }
        elsif ($@ =~ /Bad hostname/i) { $state = "dns";     }
        else                          { $state = "error";   }

        print "  => $type: $state: $@ [${duration}s]\n" if ($opts{'verbose'});
        return Flinch::Result->new('state' => $state, 'message' => $@, 'duration' => $duration);
    } elsif (! defined $response) {
        print "  => $type: unknown error [${duration}s]\n" if ($opts{'verbose'});
        return Flinch::Result->new('state' => 'unknown', 'duration' => $duration);
    } else {
        print "  => $type: ", $response->code(), " [${duration}s]\n" if ($opts{'verbose'});
        my $result = Flinch::Result->new('code' => $response->code(), 'duration' => $duration, 'lastmod' => $response->last_modified());
        if (code_is_redirect($response->code())) {
            $result->set_location($response->header('Location'));
        }
        return $result;
    }

    die("should never be here\n");
}


#-----------------------------------------------------------------------------
#
#  do_report()
#
#  Create HTML pages with report.
#
#-----------------------------------------------------------------------------
sub do_report {
    standard_init('report', 'short');

    my $dir = $cfg->get_reportdir();
    $dir =~ s/%p/$cfg->get_project()/e;

    print "Cleaning report dir\n" if ($opts{'verbose'});
    opendir(DIR, $dir) or die("Can't open report dir $dir: $!\n");
    foreach my $file (readdir(DIR)) {
        next unless ($file =~ /^(index|page-.*)\.html$/);
        unlink("$dir/$file");
    }
    closedir(DIR);

    print "Writing index.html file\n" if ($opts{'verbose'});
    my $xml = XML::Generator::Report->new('escape' => 'always',
                                          'pretty' => 2,
                                          'conformance' => 'strict');

    my $doctype = $xml->xmldtd([ 'HTML', 'PUBLIC', '"-//W3C//DTD HTML 4.01 Transitional//EN"', '"http://www.w3.org/TR/html4/loose.dtd"' ]);

    my $headtable = $xml->table(
        { 'border' => '0', 'cellpadding' => '4', 'cellspacing' => '1' },
        $xml->tr(
            $xml->td({ 'align' => 'right', 'width' => '50%' }, "Project:"),
            $xml->td($cfg->get_project()),
        ),
        $xml->tr(
            $xml->td({ 'align' => 'right', 'width' => '50%' }, "Prefix:"),
            $xml->td($cfg->get_prefix()),
        ),
        $xml->tr(
            $xml->td({ 'align' => 'right', 'width' => '50%' }, "Startpath:"),
            $xml->td(
                $xml->a(
                    { 'href' => $cfg->get_prefix() . $cfg->get_startpath(), 'class' => 'url' },
                    $cfg->get_startpath()
                ),
            ),
        ),
        $xml->tr(
            $xml->td({ 'align' => 'right', 'width' => '50%' }, "Number of Links:"),
            $xml->td(Flinch::ExternLink->num()),
        ),
    );

    my @ext_list;
    if ($opts{'short'}) {
        @ext_list = grep { $_->get_history()->get_state() ne 'ok' }
        Flinch::ExternLink->get_list();
    } else {
        @ext_list = Flinch::ExternLink->get_list();
    }

    # sort using a Schwartzian Transform
    my @links = map { $_->[0]->html_overview($xml) }
                sort { $b->[3] <=> $a->[3] or $a->[1]->cmp($b->[1]) or $a->[2] cmp $b->[2] }
                map { [ $_, $_->get_history(), $_->get_url(), $_->get_internal() ] } @ext_list;

    my %state_count;
    for my $state (map { uc($_->get_history()->get_state()) } @ext_list) {
        $state_count{$state}++;
    }

    my @stats = map { $xml->span({ 'class' => 'stat' }, $_ . ": " . $state_count{$_}) }
                sort { $state_count{$b} <=> $state_count{$a} }
                keys %state_count;

    my $body = $xml->body(
        $xml->h1($xml->em("Flinch"), " report: Overview"),
        $xml->h1("Project: " . $cfg->get_project()),
        $xml->div( { 'class' => 'center' },
            $xml->table({ 'class' => 'history', 'border' => '0', 'cellpadding' => '4', 'cellspacing' => '1', 'width' => '100%' },
                $xml->tr(
                    $xml->th(""),
                    $xml->th("Date"),
                    $xml->th("State"),
                    $xml->th("Link"),
                ),
                @links
            ),
        ),
        $xml->p({ 'class' => 'center' }, @stats),
        $xml->p({ 'class' => 'center' }, $AD_TEXT),
        $xml->p({ 'class' => 'center' }, isodate(time())),
        $xml->p({ 'class' => 'center' }, $xml->a({ 'href' => $AD_URL, 'class' => 'nav' }, $AD_URL),
        ),
    );

    my $html = $xml->html(
        $xml->head("Flinch report for project " . $cfg->get_project() . ": project overview"),
        $body,
    );

    open(HTML, ">$dir/index.html") or die("$0: can't open $dir/index.html: $!\n");
    print HTML "$doctype\n$html\n";
    close(HTML);

    print "Writing detail files\n" if ($opts{'verbose'});
    foreach (@ext_list) {
        $_->html_details($dir);
        if ($got_signal_int) {
            print STDERR "Interrupted by a signal. Report is not complete!\n";
            exit(2);
        }
    }
    write_project_xml();
}


#-----------------------------------------------------------------------------
#
#  do_mail
#
#-----------------------------------------------------------------------------
sub do_mail {
    standard_init('mail', 'force');

    my @badlinks = ();
    print "Checking all links\n" if ($opts{'verbose'});
    foreach my $link (Flinch::ExternLink->get_list()) {
        print "  ", $link->get_url->as_string(), "\n" if ($opts{'verbose'});
        my $badsince = 0;
        foreach my $result (@{$link->get_history()->get_list()}) {
            last if ($result->get_level() ne "error");
            $badsince = $result->get_time();
            print "    level=", $result->get_level(), " date=", $result->get_iso_date(), "\n" if ($opts{'verbose'});
        }
        push(@badlinks, [$link, $badsince]) if ($badsince);
    }

    my $ctime = time();
    if ($opts{'verbose'}) {
        print "Bad links:\n";
        foreach my $b (@badlinks) {
            my $link = $b->[0];
            my $since = $b->[1];
            my $w = ($ctime - $since > $cfg->get_warn_sec()) ? "warn" : "not yet";
            print "  ", $link->get_url()->as_string(), "\n";
            print "    bad since ", isodate($since), " ($w)\n";
        }
    }

    print "Writing mail\n" if ($opts{'verbose'});
    my $iso_ctime = isodate($ctime);
    (my $iso_date = $iso_ctime) =~ s/ .*//;
    my $from = $cfg->get_emailfrom();
    my $proj = $cfg->get_project();
    my $text = <<"EOF";
From: Flinch Link Checker <$from>
Subject: Flinch report for project $proj ($iso_date)

Flinch report for project '$proj'

EOF

    my @reallybadlinks = (grep { ($ctime - $_->[1] > $cfg->get_warn_sec()) ? 1 : 0 } @badlinks);
    if (@reallybadlinks) {
        foreach my $b (@reallybadlinks) {
            $text .= "* " . $b->[0]->get_url()->as_string() . "\n";
            my $days = int(($ctime-$b->[1])/(60*60*24));
            $text .= "  has not been reached since " . isodate($b->[1]) . " (> $days days)\n\n";
        }
    } else {
        # without force option no mail is sent if there is nothing to report
        if (! $opts{'force'}) {
            print "Nothing to report and force option not set\n" if ($opts{'verbose'});
            write_project_xml();
            return;
        }
        print "Nothing to report but force option is set\n" if ($opts{'verbose'});
        $text .= "Nothing to report\n\n";
    }

    $text .= "generated at $iso_ctime\n";
    $text .= "Warn threshold: " . $cfg->get_warn() . "\n\n";

    if ($cfg->get_reporturl()) {
        $text .= "For details see the HTML report at:\n";
        (my $url = $cfg->get_reporturl()) =~ s/%p/$cfg->get_project()/e;
        $text .= "$url/index.html\n";
    }

    open(SENDMAIL, "|/usr/sbin/sendmail " . $cfg->get_email()) or die("$0: can't fork sendmail: $!\n");
    print SENDMAIL $text;
    close SENDMAIL;

    write_project_xml();
}


sub isodate {
    my ($time) = @_;

    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($time);

    return sprintf("%04d-%02d-%02d %02d:%02d:%02d", $year+1900, $mon+1, $mday, $hour, $min, $sec);
}


#-----------------------------------------------------------------------------
#
#  read_xml()
#
#  Read config XML file.
#
#-----------------------------------------------------------------------------
sub read_xml {
    my ($project, $ip) = @_;

    my $fn = "$opts{'configdir'}/$project";

    print "Reading $fn.xml\n" if ($opts{'verbose'});
    $ip->{'config'} = $cfg;
    my $parser = XML::Parser::PerlSAX->new(Handler => $ip);
    eval { $parser->parse(Source=>{ SystemId => "$fn.xml" }); };
    if ($@) {
        my $msg = $@;
        $msg =~ s/\bat \/usr\/lib\/perl5.*$//;
        $msg =~ s/\n/ /mg;
        die("$0: $msg\n");
    }
}


#-----------------------------------------------------------------------------
#
#  read_config_xml()
#
#  Read main config XML file.
#
#-----------------------------------------------------------------------------
sub read_config_xml {
    read_xml('config', Flinch::ConfigParser->new());
}


#-----------------------------------------------------------------------------
#
#  read_project_xml()
#
#  Read project XML file.
#
#-----------------------------------------------------------------------------
sub read_project_xml {
    my ($project) = @_;
    read_xml($project, Flinch::Parser->new());

    if ($project ne $cfg->get_project()) {
        die("$0: project name in XML file doesn't match command line argument\n");
    }
}


#-----------------------------------------------------------------------------
#
#  write_config_xml()
#
#  Write main config XML file.
#
#-----------------------------------------------------------------------------
sub write_config_xml {
    my $fn = "$opts{'configdir'}/config";

    print "Writing $fn.xml\n" if ($opts{'verbose'});

    my $xml = XML::Generator->new('escape'      => 'always',
                                  'pretty'      => 2,
                                  'conformance' => 'strict');

    my $doctype = $xml->xmldtd([ 'flinch', 'SYSTEM', '"flinch.dtd"' ]);

    my $flinch = $xml->flinch( $cfg->xml_main($xml) );

    open(CONFIG, ">$fn.new") or die("$0: can't open $fn.new: $!\n");
    print CONFIG "<?xml version=\"1.0\"?>\n$doctype\n$flinch\n";
    if (close(CONFIG)) {
        rename("$fn.new", "$fn.xml");
    } else {
        print STDERR "$0: Close failed. Temporary file not deleted. See config directory.\n";
    }
}


#-----------------------------------------------------------------------------
#
#  write_project_xml()
#
#  Write project XML file.
#
#-----------------------------------------------------------------------------
sub write_project_xml {
    my $fn = "$opts{'configdir'}/" . $cfg->get_project();

    print "Writing $fn.xml\n" if ($opts{'verbose'});

    my $xml = XML::Generator->new('escape'      => 'always',
                                  'pretty'      => 2,
                                  'conformance' => 'strict');

    my $doctype = $xml->xmldtd([ 'flinch', 'SYSTEM', '"flinch.dtd"' ]);

    my $last = $xml->last( { %last });

    my @skip = map { $_->xml($xml) } sort(Flinch::Skip->list_all());

    # sort using a Schwartzian Transform
    my @link = map { $_->[0]->xml($xml) }
               sort { $a->[1] cmp $b->[1] }
               map { [ $_, $_->get_url()->as_string() ] }
               Flinch::ExternLink->get_list();

    my $flinch = $xml->flinch($cfg->xml_project($xml), $last, @skip, @link);

    open(PROJECT, ">$fn.new") or die("$0: can't open $fn.new: $!\n");
    print PROJECT "<?xml version=\"1.0\"?>\n$doctype\n$flinch\n";
    if (close(PROJECT)) {
        rename("$fn.new", "$fn.xml");
    } else {
        print STDERR "$0: Close failed. Temporary file not deleted. See config directory.\n";
    }
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::ConfigParser
#
#  This is the parser for the main config XML file.
#
#-----------------------------------------------------------------------------
package Flinch::ConfigParser;

sub new {
    my $type = shift;
    return bless {}, $type;
}


sub start_element {
    my ($self, $args) = @_;

    my $element = $args->{'Name'};

    # store element name so that we know it if there is any text to be handled
    $self->{'element'} = $element;
    $self->{'text'} = "";

    # store broader context
    if ($element eq 'config') {
        $self->{'context'} = 'config';
    }
}


sub end_element {
    my ($self, $args) = @_;

    if ($args->{'Name'} eq $self->{'context'}) {
        delete $self->{'context'};
    }

    if ($self->{'context'} eq 'config') {
        $self->{'text'} =~ s/\s+/ /gm;
        $self->{'text'} =~ s/^ //;
        $self->{'text'} =~ s/ $//;
        $self->{'config'}->set('main', $self->{'element'}, $self->{'text'});
    }

    delete $self->{'element'};
    delete $self->{'text'};
}


sub characters {
    my ($self, $args) = @_;

    return unless ($self->{'element'});

    if (($self->{'element'} ne 'config') && ($self->{'context'} eq 'config')) {
        $self->{'text'} .= $args->{'Data'};
    }
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::Parser
#
#  This is the parser for the project XML file.
#
#-----------------------------------------------------------------------------
package Flinch::Parser;

sub new {
    my $type = shift;
    return bless {}, $type;
}


sub start_element {
    my ($self, $args) = @_;

    my $element = $args->{'Name'};
    my $attr = $args->{'Attributes'};

    # store element name so that we know it if there is any text to be handled
    $self->{'element'} = $element;
    $self->{'attributes'} = $attr;
    $self->{'text'} = "";

    # store broader context
    if ($element =~ /^(config|link|skip)$/) {
        $self->{'context'} = $element;
    }

    if ($element eq 'link') {
        $self->{'link'} = Flinch::ExternLink->new($attr->{'to'});
        $self->{'link'}->set_method($attr->{'method'}) if ($attr->{'method'});
    } elsif ($element eq 'result') {
        my $result = Flinch::Result->new(%$attr);
        $self->{'link'}->get_history()->add($result);
    } elsif ($element eq 'history') {
        $self->{'link'}->get_history()->set_keep($attr->{'keep'});
    } elsif ($element eq 'last') {
        %last = %$attr;
    }
}


sub end_element {
    my ($self, $args) = @_;

    if ($args->{'Name'} eq $self->{'context'}) {
        delete $self->{'context'};
        delete $self->{'link'};
    }

    if ($self->{'context'} eq 'config') {
        $self->{'config'}->set('project', $self->{'element'}, $self->{'text'});
    }

    if ($args->{'Name'} eq "ref") {
        $self->{'link'}->add_ref($self->{'text'});
    }

    if ($args->{'Name'} eq "skip") {
        Flinch::Skip->new(
            $self->{'attributes'}->{'type'},
            $self->{'attributes'}->{'action'},
            $self->{'text'}
        );
    }

    if ($args->{'Name'} eq "comment") {
        $self->{'link'}->set_comment($self->{'text'});
    }

    delete $self->{'element'};
    delete $self->{'attributes'};
    delete $self->{'text'};
}


sub characters {
    my ($self, $args) = @_;

    return unless ($self->{'element'});

    my $data = $args->{'Data'};
    my $ctx  = "$self->{'context'}/$self->{'element'}";

    if ($ctx eq "config/config") {
        return;
    }

    if ($self->{'context'} eq 'config') {
        $data =~ s/\s//gm;
        $self->{'text'} .= $data;
        return;
    }

    if (($ctx eq "link/comment") ||
        ($ctx eq "link/ref") ||
        ($ctx eq "skip/skip")) {
        $self->{'text'} .= $data;
        return;
    }
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::ExternLink
#
#  An object in this class represents an external link.
#
#-----------------------------------------------------------------------------
package Flinch::ExternLink;

my %list = ();


# create a new link and add it to the list
sub new {
    my ($class, $url, $ref) = @_;

    my $self;
    if ($list{$url}) {
        $self = $list{$url};
    } else {
        $self = bless({}, $class);
        $list{$url} = $self;
        $self->set_url(URI->new($url));
    }

    my $pre = $cfg->get_prefix();
    $self->set_internal() if ($url =~ /^$pre/o);

    $self->add_ref($ref) if ($ref);
    $self->set_history(Flinch::History->new()) unless ($self->get_history());
    return $self;
}


# remove a link from the list
sub remove { delete $list{$_[0]->{'url'}}; }


# add a reference to a link
sub add_ref { $_[0]->{'ref'}->{$_[1]} = 1; }


# accessor functions
sub get_list    { return values(%list); }

sub get_comment { return $_[0]->{'comment'}; }
sub get_history { return $_[0]->{'history'}; }
sub get_method  { return $_[0]->{'method'};  }
sub get_url     { return $_[0]->{'url'};     }

sub get_refs    { return keys(%{$_[0]->{'ref'}}); }  # returns array

sub set_comment { $_[0]->{'comment'} = $_[1]; }
sub set_history { $_[0]->{'history'} = $_[1]; }
sub set_method  { $_[0]->{'method'}  = $_[1]; }
sub set_url     { $_[0]->{'url'}     = $_[1]; }

sub get_internal { return $_[0]->{'internal'} ; }
sub set_internal { $_[0]->{'internal'} = 1    ; }

sub flush_ref   { $_[0]->{'ref'}     = {}; }


# return unique id for this link
sub get_unique_id() {
    my ($self) = @_;
    $self =~ /.*\(0x([0-9a-f]*)\).*/;
    return $1;
}


# is this link referenced anywhere?
sub is_referenced {
    my ($self) = @_;
    my @ref = keys(%{$self->{'ref'}});
    return ($#ref >= 0);
}


# return the number of external links
sub num {
    return scalar(@{[%list]})/2;
}


# come up with some similar URLs in case the user wants to check them
sub similar {
    my ($self) = @_;

    my $url = $self->{'url'}->clone();
    $url->query(undef);
    $url->fragment(undef);

    my @r;

    # try with https
    if ($url->scheme eq 'http') {
        my $https_url = $url->clone();
        $https_url->scheme('https');
        push(@r, $https_url->as_string());
    }

    # try with path components
    my @seg = $url->path_segments();
    foreach my $n (0 .. $#seg) {
        $url->path_segments(@seg[0..$n]);
        unshift(@r, $url->as_string());
    }

    # try without port if any
    if ($url->_port()) {
        $url->_port(undef);
        push(@r, $url->as_string());
    }

    # try www|ftp.domain
    my $hn = "www";
    $hn = "ftp" if ($url->scheme() eq "ftp");
    my @domain = split(/\./, $url->host());
    if ($domain[0] ne $hn) {
        if ($#domain == 1) {
            unshift(@domain, $hn);
        } else {
            $domain[0] = $hn;
        }
        $url->path("");
        $url->host(join('.', @domain));
        push(@r, $url->as_string());
    }

    return @r;
}


# output XML version of link object as persistent storage
sub xml {
    my ($self, $xml) = @_;

    my @ref = map { $xml->ref($_) } sort $self->get_refs();

    return $xml->link(
        { 'to'     => $self->get_url()->as_string(),
          'method' => $self->get_method() },
        $self->get_comment() ? $xml->comment($self->get_comment()) : "",
            @ref,
            $self->get_history()->xml($xml),
    );
}


# output link list for HTML report, overview page
sub html_overview {
    my ($self, $xml) = @_;

    my $u = $self->get_url()->as_string();
    my $ux = substr($u, 0, 60);

    my $location = $self->get_history()->get_location();
    if ($location ne '') {
        my $us = $u;
        $us =~ s/^http:/https:/;
        if ($u =~ /^http:/ && $location =~ /^https:/ && $us eq $location) {
            $location = ' => HTTPS'
        } else {
            $location = ' => ' . $location;
        }
    }

    return $xml->tr(
        $xml->td({ 'class' => 'nav' },
            $xml->a({ 'href'  => "page-" . $self->get_unique_id() . ".html", 'class' => 'nav' }, "Details"),
        ),
        $xml->td({ 'align' => 'middle' },
            $self->get_history()->get_iso_date(),
        ),
        $xml->td(
            {'class' => ($self->get_internal() ? "int" : "") . $self->get_history()->get_level() },
            uc($self->get_history()->get_state())
        ),
        $xml->td(
            $xml->a({'href' => $u, 'class' => 'url' }, $ux),
            ($ux eq $u) ? "" : "...",
            $location
        ),
    );
}


# output detailed HTML report page for this link
sub html_details {
    my ($self, $dir) = @_;

    my $prefix = $self->get_internal() ? "int" : "";

    my $xml = XML::Generator::Report->new('escape' => 'always',
                                          'pretty' => 2,
                                          'conformance' => 'strict');

    my $doctype = $xml->xmldtd([ 'HTML', 'PUBLIC', '"-//W3C//DTD HTML 4.01 Transitional//EN"', '"http://www.w3.org/TR/html4/loose.dtd"' ]);

    my $title = "Flinch report for project " . $cfg->get_project() . ": link details";

    my $selfhist = $self->get_history();
    my $history = $selfhist->is_empty() ? "not checked yet" :
        $xml->div({ 'class' => 'back' }, $selfhist->html($xml, $prefix));

    my $lastmod = $selfhist->is_empty() ? "not checked yet" :
        main::isodate($selfhist->get_lastmod()) . " (" . int((time() - $selfhist->get_lastmod()) / (60*60*24)) . " days ago)";

    my @refs;
    if ($cfg->get_reportprefix()) {
        my $p1 = $cfg->get_prefix();
        my $p2 = $cfg->get_reportprefix();
        @refs = map { s/^$p1/$p2/; $_; } $self->get_refs();
    } else {
        @refs = $self->get_refs();
    }

    my @to = map { $xml->li($xml->a({'href' => $_ }, $_)) } @refs;

    my @similar = map { $xml->li($xml->a( { 'href' => $_ }, $_)) } $self->similar();

    my $options = "";
    if ($self->get_history()->get_keep()) {
        $options .= "keep=" . $self->get_history()->get_keep();
    }

    my $table = $xml->table( { 'width' => '100%', 'cellspacing' => '1', 'cellpadding' => '6', 'border' => '0', 'class' => 'main' },
        $xml->tr(
            $xml->th( { 'class' => 'main' }, "Link to" ),
            $xml->td(
                $xml->a(
                    { 'href' => $self->get_url()->as_string(),
                    'class' => 'url' },
                    $self->get_url()->as_string()
                    ),
            ),
        ),
        $options ? $xml->tr(
            $xml->th( { 'class' => 'main' }, "Options" ),
            $xml->td( $options ),
        ) : (),
        $self->{'comment'} ? $xml->tr(
            $xml->th( { 'class' => 'main' }, "Comment" ),
            $xml->td( $self->{'comment'} ),
        ) : (),
        $xml->tr(
            $xml->th( { 'class' => 'main' }, "Check history" ),
            $xml->td( $history ),
        ),
        $xml->tr(
            $xml->th( { 'class' => 'main' }, "Last modified" ),
            $xml->td( $lastmod ),
        ),
        $xml->tr(
            $xml->th( { 'class' => 'main' }, "Referenced from" ),
            $xml->td( $xml->ul( {'class' => 'urllist'}, @to) ),
        ),
        $xml->tr(
            $xml->th( { 'class' => 'main' }, "Similar URLs" ),
            $xml->td( $xml->ul( {'class' => 'urllist'}, @similar) ),
        ),
    );

    my $body = $xml->body(
        $xml->h1($xml->em("Flinch"), " report: Link details"),
        $xml->h1("Project: " . $cfg->get_project()),
        $xml->p( { 'class' => 'center' },
            "[ ",
            $xml->a( { 'class' => 'nav', 'href' => 'index.html' }, "to project overview"),
            " ]",
        ),
        $xml->div( { 'class' => 'center' },
            $table,
        ),
    );

    my $html = $xml->html(
        $xml->head($title),
        $body,
    );

    my $file = 'page-' . $self->get_unique_id() . '.html';
    open(DETAILS, ">$dir/$file") or die("$0: can't open $dir/$file: $!\n");
    print DETAILS "$doctype\n$html\n";
    close(DETAILS);
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::Skip
#
#-----------------------------------------------------------------------------
package Flinch::Skip;

use constant SKIP_TYPE    => 0;
use constant SKIP_ACTION  => 1;
use constant SKIP_CONTENT => 2;


# list of all skip objects
my @list;


# create a new skip object
sub new {
    my ($class, $type, $action, $cont) = @_;
    my $self = [$type, $action, $cont];

    $self->[SKIP_ACTION] = 'nofollow' unless ($action);

    push(@list, $self);
    return bless($self, $class);
}


# accessor functions
sub get_type      { return $_[0]->[SKIP_TYPE];    }
sub get_action    { return $_[0]->[SKIP_ACTION];  }
sub get_content   { return $_[0]->[SKIP_CONTENT]; }

sub list_all      { return                                         @list; }
sub list_nofollow { return grep { $_->get_action() eq "nofollow" } @list; }
sub list_ignore   { return grep { $_->get_action() eq "ignore"   } @list; }


# output XML version of skip object as persistent storage
sub xml {
    my ($self, $xml) = @_;

    return $xml->skip(
        { 'type' => $self->get_type(), 'action' => $self->get_action() },
        $self->get_content()
    );
}


# match url against a skip object
sub match {
    my ($self, $url) = @_;

    my $t = $self->get_type();
    my $c = $self->get_content();

    if      ($t eq 'prefix') { return ($url =~ /^$c/);
    } elsif ($t eq 'suffix') { return ($url =~ /$c(\?.*)?$/);
    } elsif ($t eq 'regex')  { return ($url =~ /$c/);
    } elsif ($t eq 'url')    { return ($url eq $c);
    } else {
        die("$0: unknown skip type: $t\n");
    }
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::History
#
#-----------------------------------------------------------------------------
package Flinch::History;

use constant HISTORY_LIST => 0;
use constant HISTORY_KEEP => 1;


# create a new history object
sub new {
    my ($class, $keep) = @_;
    return bless([[], $keep], $class);
}


# add a result to the history
sub add {
    my ($self, $result) = @_;

    # sort using a Schwartzian Transform
    my @h = map { $_->[0] }
            sort { $b->[1] <=> $a->[1] }
            map { [ $_, $_->get_time() ] }
            (@{$self->get_list()}, $result);

    if ($self->get_keep()) {
        splice(@h, $self->get_keep());
        $self->set_list(\@h);
    } else {
        my @new;
        foreach my $h (@h) {
            push(@new, $h);
            last if ($h->get_level() eq "ok");
        }
        $self->set_list(\@new);
    }

    return $result;
}


# acessor functions
sub get_list { return $_[0]->[HISTORY_LIST]; }
sub get_keep { return $_[0]->[HISTORY_KEEP]; }
sub is_empty { return ! defined $_[0]->get_list()->[0]; }


sub set_list {
    my ($self, $list) = @_;
    return $self->[HISTORY_LIST] = $list;
}

sub clean {
    my ($self) = @_;
    my @list = @{$self->get_list()};
    if ($#list > 2) {
        $self->set_list([$list[0], $list[-1]]);
    }
}

sub set_keep {
    my ($self, $keep) = @_;
    return $self->[HISTORY_KEEP] = $keep;
}


# some accessor functions for the last checks of this history
sub get_time {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_time() : 0;
}


sub get_iso_date {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_iso_date() : "not checked";
}


sub get_state {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_state() : "unchecked";
}


sub get_location {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->{'location'} : ''
}


sub get_duration {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_duration() : "unknown";
}


sub get_lastmod {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_lastmod() : 0;
}


sub get_level {
    my ($self) = @_;
    my $f = $self->get_list()->[0];
    return $f ? $f->get_level() : "unchecked";
}


# compare two history entries by comparing the last results
sub cmp {
    my ($a, $b) = @_;

    return 0 if ($a->is_empty() and $b->is_empty());

    my $ac = $a->get_list()->[0];
    my $bc = $b->get_list()->[0];
    return  1 unless (defined $ac);
    return -1 unless (defined $bc);
    return $ac->cmp($bc);
}


# output XML version of history object as persistent storage
sub xml {
    my ($self, $xml) = @_;

    return $xml->history( { 'keep' => $self->get_keep() },
        map { $_->xml($xml) } @{$self->get_list()} );
}


# pretty printing HTML for report
sub html {
    my ($self, $xml, $prefix) = @_;

    return $xml->table(
        { 'class' => 'history', 'cellspacing' => '1', 'cellpadding' => '2', 'border' => '0' },
        $xml->tr(
            $xml->th("Date"),
            $xml->th("Time"),
            $xml->th("Duration"),
            $xml->th("State"),
            $xml->th("Code"),
            $xml->th("Message"),
            $xml->th("New location"),
        ),
        map { $_->html($xml, $prefix) } @{$self->get_list()},
    );
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::Result
#
#  This class represents a link check that was performed at some point in
#  time.
#
#-----------------------------------------------------------------------------
package Flinch::Result;

use vars qw(%SORT_ORDER %state2level);

BEGIN {
    my $n=0;

    # this is the sort order for the HTML report, bad cases first
    %SORT_ORDER = map { $_ => $n++ } (
        'forbidden', 'not auth', 'not found', 'empty',
        'dns', 'timeout', 'error', 'unknown', 'multi',
        'moved',
        'redirect', 'http', 'ok',
        'unchecked'
    );

    %state2level = (
        'forbidden' => 'error',
        'not auth'  => 'error',
        'not found' => 'error',
        'empty'     => 'error',
        'dns'       => 'error',
        'timeout'   => 'error',
        'error'     => 'error',
        'unknown'   => 'error',
        'multi'     => 'warn',
        'moved'     => 'warn',
        'redirect'  => 'ok',
        'http'      => 'ok',
        'ok'        => 'ok',
        'unchecked' => 'unchecked',
    );
}


sub new {
    my ($class, %init) = @_;

    my $self = \%init;

    $self->{'time'} = time() unless ($self->{'time'});

    $self->{'state'} = code2state($self->{'code'}) unless(defined $self->{'state'});

    return bless($self, $class);
}


sub code2state {
    my ($code) = @_;

    return 'ok'        if ($code == 200);    # 200 ok
    return 'empty'     if ($code == 204);    # 204 no content
    return 'ok'        if ($code == 205);    # 205 reset content
    # this is actually a bogus answer from a strange server. but netscape
    # shows the page, so it must be ok :-)

    return 'multi'     if ($code == 300);    # 300 multiple choices
    return 'moved'     if ($code == 301);    # 301 permanent redirect
    return 'redirect'  if ($code == 302);    # 302 temporary redirect
    return 'redirect'  if ($code == 307);    # 307 temporary redirect
    return 'moved'     if ($code == 308);    # 308 permanent redirect
    return 'not auth'  if ($code == 401);    # 401 unauthorized
    return 'forbidden' if ($code == 403);    # 403 forbidden
    return 'not found' if ($code == 404);    # 404 not found
    return 'timeout'   if ($code == 408);    # 408 request timeout
    return 'moved'     if ($code == 410);    # 410 gone
    return 'timeout'   if ($code == 503);    # 503 service unavailable
    return 'timeout'   if ($code == 504);    # 504 gateway timeout

    return 'error'     if ($code >= 500);    # server errors
    return 'error'     if ($code >= 400);    # client errors
    return 'unknown';
}


# accessor functions
sub get_state     { return $_[0]->{'state'};    }
sub get_code      { return $_[0]->{'code'};     }
sub get_time      { return $_[0]->{'time'};     }
sub get_duration  { return $_[0]->{'duration'}; }
sub get_lastmod   { return $_[0]->{'lastmod'}; }


sub set_state {
    my ($self, $state) = @_;
    $self->{'state'} = $state;
}


# set location for redirects
sub set_location {
    my ($self, $location) = @_;
    $self->{'location'} = $location;
}


# return level
sub get_level {
    my ($self) = @_;
    return $state2level{$self->{'state'}};
}


# return the date using ISO format
sub get_iso_date {
    my ($self) = @_;

    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        localtime($self->get_time());

    return sprintf("%04d-%02d-%02d", $year+1900, $mon+1, $mday);
}


# return the time using ISO format
sub get_iso_time {
    my ($self) = @_;

    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        localtime($self->get_time());

    return sprintf("%02d:%02d:%02d", $hour, $min, $sec);
}


# compare two check results. this is used by the sorting function for pretty
# printing the report
sub cmp {
    my ($a, $b) = @_;

    return  1 unless (defined $a);
    return -1 unless (defined $b);

    return $SORT_ORDER{$a->{'state'}} <=> $SORT_ORDER{$b->{'state'}};
}


# return XML version of object for persistent storage
sub xml {
    my ($self, $xml) = @_;

    return $xml->result( { %$self } );
}


# return HTML report for this check
sub html {
    my ($self, $xml, $prefix) = @_;

    my $msg;
    if ($self->{'message'}) {
        $msg = $self->{'message'};
        $msg =~ s/at \/.*//;
    } else {
        $msg = HTTP::Status::status_message($self->{'code'});
        $msg = 'N/A' unless ($msg);
    }

    my $loc;
    if ($self->{'location'}) {
        $loc = $xml->a({ 'href' => $self->{'location'}, 'class' => 'url' }, $self->{'location'})
    } else {
        $loc = 'N/A';
    }

    return $xml->tr(
        $xml->td( $self->get_iso_date() ),
        $xml->td( $self->get_iso_time() ),
        $xml->td( $self->get_duration() || 'unknown' ),
        $xml->td( { 'class' => $prefix . $self->get_level() }, uc($self->{'state'}) ),
        $xml->td( $self->{'code'} ),
        $xml->td( $msg ),
        $xml->td( $loc ),
    );
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::URLList
#
#  This class keeps track of the list of internal URLs when walking the
#  web site.
#
#-----------------------------------------------------------------------------
package Flinch::URLList;

use constant URL_TODO => 0;
use constant URL_DONE => 1;

my %refs = ();

# create new list of URLs
sub new {
    my ($class) = @_;
    return bless({}, $class);
}

sub bad_refs {
    my ($self, $url) = @_;
    my ($i);
    foreach $i (split /\n/, $refs{$url}) {
        Flinch::ExternLink->new($url, $i, 1);
        print "  INTERN $url <- $i\n" if ($opts{'verbose'} > 1);
    }
}

# add url to list if it is not already there
sub push {
    my ($self, $url, $l) = @_;

    if (! defined $self->{$url}) {
        $self->{$url} = URL_TODO;
        $refs{$url} = $l if (defined $l);
    } elsif (($self->{$url} == URL_DONE) && (defined $failed{$url})) {
        Flinch::ExternLink->new($url, $l, 1);
        print "  INTERN $url <- $l\n" if ($opts{'verbose'} > 1);
    } elsif ($self->{$url} == URL_TODO && defined $l) {
        $refs{$url} .= "\n$l";
    }
}


# return the first url in the list that hasn't been dealed with yet and mark
# it as done
sub pop {
    my ($self) = @_;

    foreach my $url (keys(%$self)) {
        if ($self->{$url} == URL_TODO) {
            $self->{$url} = URL_DONE;
            return $url;
        }
    }
    return undef;
}


#-----------------------------------------------------------------------------
#
#  PACKAGE Flinch::Config
#
#  This class represents the configuration.
#
#-----------------------------------------------------------------------------
package Flinch::Config;

use Carp;

use constant CONFIG_DEFAULT => 0;
use constant CONFIG_MAIN    => 1;
use constant CONFIG_PROJECT => 2;
use constant CONFIG_CMDLINE => 3;
use constant CONFIG_MISC    => 4;

use vars '@cfgvars';

# define accessor (get_*, set_*) functions
BEGIN  {
    @cfgvars = qw( email emailfrom prefix project reportdir reportprefix reporturl schemes startpath stylesheet timeout sleep useragent warn );

    foreach my $attr (@cfgvars) {
        no strict 'refs';
        *{"Flinch::Config::get_$attr"} = sub { $_[0]->get($attr); };
        *{"Flinch::Config::set_$attr"} = sub { $_[0]->set('project', $attr, $_[1]); };
    }
}


sub new {
    my ($class, %init) = @_;

    my $self = [ {}, {}, {}, {}, {} ];
    $self->[CONFIG_DEFAULT] = \%init;

    return bless($self, $class);
}


# get a config variable
sub get {
    my ($self, $var) = @_;

    foreach my $h ( map { $self->[$_] } (3, 2, 1, 0)) {
        return $h->{$var} if (exists $h->{$var});
    }
    return undef;
}


# set a config variable
sub set {
    my ($self, $which, $var, $value) = @_;
    my %wl = (
        'default' => CONFIG_DEFAULT,
        'main'    => CONFIG_MAIN,
        'project' => CONFIG_PROJECT,
        'cmdline' => CONFIG_CMDLINE,
    );
    $self->[$wl{$which}]->{$var} = $value;
}


sub check_complete {
    my ($self) = @_;

    foreach my $var (@cfgvars) {
        if (! defined $cfg->get($var)) {
            die("Missing configuration setting for '$var'\n");
        }
    }
}


# check scheme against config
sub scheme_ok {
    my ($self, $scheme) = @_;

    return ($self->get_schemes() =~ /\b$scheme\b/) ? 1 : 0;
}


# get warn interval in seconds
sub get_warn_sec {
    my ($self) = @_;

    # check memoized version
    return $self->[CONFIG_MISC]->{'warnsec'} if (exists($self->[CONFIG_MISC]->{'warnsec'}));

    my %mul = ( 's' => 1,
                'm' => 60,
                'h' => 60*60,
                'd' => 60*60*24,
                'w' => 60*60*24*7 );

    my $sec = 0;

    my $str = $self->get_warn();
    while ($str =~ /([0-9]+)([wdhms])/g) {
        $sec += $1 * $mul{$2};
    }

    $self->[CONFIG_MISC]->{'warnsec'} = $sec;
    return $sec;
}


# dump current config settings for debug
sub dump {
    my ($self) = @_;

    my @l = ('default', 'main', 'project', 'cmdline');

    print "Configuration:\n";
    foreach my $level (0 .. 2) {
        print "  $l[$level]:\n";
        foreach my $key (sort(keys(%{$self->[$level]}))) {
            print "    $key=$self->[$level]->{$key}\n";
        }
    }
}


# write config in XML format
sub xml {
    my ($self, $which, $xml) = @_;

    return $xml->config(
        map { $xml->$_($self->[$which]->{$_}) } sort keys(%{$self->[$which]})
    );
}


# write main/project config in XML format
sub xml_main    { return shift->xml(CONFIG_MAIN,    @_); }
sub xml_project { return shift->xml(CONFIG_PROJECT, @_); }


#-----------------------------------------------------------------------------
#
#  PACKAGE XML::Generator::Report;
#
#  This is a subclass of XML::Generator which overwrites the head() function
#  to output some generic meta information.
#
#-----------------------------------------------------------------------------
package XML::Generator::Report;
use base 'XML::Generator';

sub head {
    my ($self) = @_;

    # parse our args to get namespace and attribute info
    my($namespace, $attr, @content) = XML::Generator::util::parse_args(@_);

    my @h = (
        $self->xmlcmnt($AD_TEXT),
        $self->title(@content),
        $self->meta( { 'http-equiv' => 'content-type',
                       'content'    => 'text/html' } ),
        $self->meta( { 'http-equiv' => 'expires',
                       'content'    => '0' } ),
        $self->meta( { 'http-equiv' => 'pragma',
                       'content'    => 'no-cache' } ),
        $self->meta( { 'http-equiv' => 'cache-control',
                       'content'    => 'no-cache,must-revalidate' } ),
        $self->link( { 'rel'  => 'stylesheet',
                       'type' => 'text/css',
                       'href' => $cfg->get_stylesheet() } )
    );

    $self->SUPER::head(@h);
}


#-- THE END ------------------------------------------------------------------
